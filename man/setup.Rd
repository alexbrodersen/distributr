% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sge_setup.R
\name{setup}
\alias{setup}
\alias{setup.gapply}
\title{Setup SGE jobs}
\usage{
setup(object, ...)

\method{setup}{gapply}(object, .dir = getwd(), .reps = 1, .seed = NULL,
  .mc.cores = 1, .verbose = 1, .queue = "long",
  .script.name = "doone.R", .job.name = "distributr",
  .out.dir = "SGE_Output", .R.version = "3.2.5", .email.options = "a",
  .email.addr = NULL, .shell = "bash", ...)
}
\arguments{
\item{object}{object from \code{grid_apply} or \code{gapply} with \code{.eval=FALSE}}

\item{...}{arguments to methods}

\item{.dir}{directory name relative to the current working directory (no trailing backslash)}

\item{.reps}{total number of replications for each condition}

\item{.seed}{An integer or \code{NULL} (default, no seeds are set automatically). If given, controls
RNG using L'ecuyer-CMRG as in \code{parallel} by saving and accessing unique seeds in \code{seeds.Rdata}}

\item{.mc.cores}{number of cores used to run replications in parallel (can be a range)}

\item{.verbose}{verbose level: \code{1} prints '.' for each replication,
\code{2} prints '.' on completion and prints the current arguments,
\code{3} prints the current arguments and results}

\item{.queue}{name of queue}

\item{.script.name}{name of script (default \code{doone.R})}

\item{.job.name}{name of job}

\item{.out.dir}{name of directory in which to put SGE output files.}

\item{.R.version}{name of R version. Possible values include any in \code{module avail}. Default is 3.2.5.}

\item{.email.options}{one or more characters from "bea" meaning email when "job Begins", "job Ends", and "job Aborts". Default is "a".}

\item{.email.addr}{email address}

\item{.shell}{shell to use. Default is 'bash'}
}
\value{
Invisibly, the original object with argument grid modified to append a
column \code{$.sge_id} assigning each row to a unique job id.

As side effects, the function writes the following objects to \code{.dir}:
\item{arg_grid.Rdata}{Data frame containing the argument grid,
appended with a column \code{sge_id} corresponding to the task id of each row}
\item{doone.R}{Script to run one job, or one row from \code{arg_grid}}
\item{submit}{Submission script specifying a task array over the grid of parameters
in (all rows of) arg_grid.Rdata}
\item{seeds.Rdata}{If \code{.seed} is specified, a list of seeds for each job.}
\item{results/}{Folder to store results. Each file is \code{1.Rdata}, \code{2.Rdata}, ...
corresponding to the task id (row in \code{arg_grid})}
\item{SGE_Output/}{ Folder for output from SGE}
}
\description{
In a given directory, writes the argument grid given from \code{grid_apply(.f, ..., .eval=FALSE)},
an Rscript to run \code{.f} on one set of arguments,
a submission script to run \code{.f} on combination of arguments,
and directories to store results and job log files.
}
\details{
Long running \code{grid_apply} computations can be easily run in parallel on
SGE using array tasks. Each row in the argument grid given by \code{grid_apply(f, ...)}
is mapped to a unique task id, which is run on a separate node.
 \code{setup()} makes this easy by writing
the argument grid (\code{arg_grid.Rdata}), an R script to run one combination of arguments, a submission
script assigning all rows to a unique task id, seeds (if specified), and folders to store results in
a given directory. Jobs are submitted to the scheduler by running \code{qsub submit}
at the prompt, or by running \code{submit()} within R.

The argument grid (\code{arg_grid}) is saved to \code{.dir} as \code{arg_grid.Rdata}.
It contains the columns of \code{expand.grid(...)} from \code{grid_apply(.f, ...)}.
A column \code{$.sge_id} is appended that assigns each row a unique job id.

A simple R script (\code{doone.R}) is provided that runs \code{.f} on one row
of \code{arg_grid}. Running \code{doone.R} at the command line exactly replicates
how the script will be run on each node.

A file (\code{submit}) is also written, which specifies a task array for \code{qsub}
for all jobs in \code{arg_grid}. It can be submitted to the queue by running
\code{qsub submit} at the command line. Job status can be monitored with \code{qstat}.
Various email

Results are stored in \code{results/}, as \code{$SGE_TASK_ID.Rdata} where
\code{SGE_TASK_ID} is the array task corresponding to a unique row in \code{arg_grid}.
It is sometimes convenient to access this variable within \code{.f}, which can
be done by \code{Sys.getenv("SGE_TASK_ID")}. This might be used to
cache intermediate results.


If \code{.seed} is given, a list of seeds is generated in \code{seeds.Rdata} using
 L'ecuyer-CMRG streams for reproducible random number generation. A unique seed is
 generated for each independent job in the argument grid.
 Subsequent calls to setup using the same .seed generate the same seeds and reproducible results.
 See \code{parallel::nextRNGStream} for more details.

The function \code{.f} can be run multiple times for every row in \code{arg_grid}
by setting \code{.reps > 1}. These replications can be run in parallel using
\code{mclapply} by setting \code{.mc.cores > 1}. To decrease waiting times in the queue,
\code{mc.cores} can be given a range (e.g. \code{mc.cores = c(1, 8)}), and the job will
be submitted when a given set of cores in that range is available. To access the
number of cores given to each job, use \code{Sys.getenv("NSLOTS")}.

It is easy to corrupt \code{arg_grid.Rdata} by running \code{setup} on different
sets of arguments, making future merges of results with arguments based on
\code{.sge_id} invalid. If \code{arg_grid.Rdata} already exists, \code{setup}
prompts the user for verification that an overwrite is intended, or stops with an error
if not run interactively.
}
\section{Methods (by class)}{
\itemize{
\item \code{gapply}: Setup sge files from \code{gapply, grid_apply}
}}
\examples{
\dontrun{
do.one <- function(a, b){c(sum=a+b, sub=a-b)}
plan <- grid_apply(do.one, a=1:5, b=3, .eval=FALSE)
jobs(plan)  # shows the original argument grid
plan <- setup(plan, .reps=5, .mc.cores=c(1, 5))
jobs(plan)  # modified with a column showing unique job ids
}
}
\seealso{
\link{grid_apply} to define the grid, \link{jobs} to see the grid,
\link{collect} to collect completed results, and \link{tidy} to merge
completed results with the argument grid.
 \link{test_job} Runs a job with a given id on the head node.
 \link{filter_jobs} writes a submission script for jobs matching conditions as in \code{dplyr::filter}
 \link{sge_env} can be used to access environmental variables.
}

